package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
)

func main() {
	var filename string
	flag.StringVar(&filename, "name", "", "Name of the file to search for slice types")
	flag.Parse()

	slices, err := parseFile(filename)
	if err != nil {
		fmt.Printf("Error parsing file %s %s\n", filename, err)
		os.Exit(1)
	}

	for _, slice := range slices {
		generateCollections(slice)
		fmt.Printf("Generated for type %s\n", slice.sliceName)
	}
}

type sliceInfo struct {
	filename      string
	packageName   string
	sliceName     string
	sliceItemName string
}

func parseFile(filename string) ([]sliceInfo, error) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filename, nil, 0)
	if err != nil {
		return nil, err
	}

	var result []sliceInfo
	var packageName string

	ast.Inspect(f, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.File:
			packageName = x.Name.Name
		case *ast.TypeSpec:
			atype := x.Type
			arrayType, ok := atype.(*ast.ArrayType)
			if !ok {
				return true
			}
			sliceTypeName := x.Name.Name
			elt, ok := arrayType.Elt.(*ast.Ident)
			if !ok {
				return true
			}
			result = append(result, sliceInfo{
				filename:      filename,
				packageName:   packageName,
				sliceName:     sliceTypeName,
				sliceItemName: elt.Name,
			})
		}
		return true
	})

	return result, nil
}

type templateData struct {
	PackageName string
	Type        string
	ItemType    string
}

func generateCollections(info sliceInfo) {
	templateData := templateData{
		PackageName: info.packageName,
		Type:        info.sliceName,
		ItemType:    info.sliceItemName,
	}

	filename := strings.ToLower(info.sliceName) + "_collection.go"
	f, err := os.Create(filename)
	if err != nil {
		fmt.Printf("error creating output file %s, %s", filename, err.Error())
		os.Exit(1)
	}

	err = t.Execute(f, templateData)
	if err != nil {
		fmt.Printf("error executing template %s", err.Error())
		os.Exit(1)
	}

	err = f.Close()
	if err != nil {
		fmt.Printf("error closing output file %s, %s", filename, err.Error())
		os.Exit(1)
	}
}

var t = template.Must(template.New("collection").Parse(ctemplate))

const ctemplate = `// generated by collections; DO NOT EDIT

package {{.PackageName}}

import (
	"fmt"
	"sort"
)

type Eligible{{.ItemType}}FilterFunc func(item {{.ItemType}}) bool

func (collection {{.Type}}) Filter(eligible Eligible{{.ItemType}}FilterFunc) {{.Type}} {
	var result {{.Type}}
	for _, item := range collection {
		if !eligible(item) {
			result = append(result, item)
		}
	}
	return result
}

func (collection {{.Type}}) All(eligible Eligible{{.ItemType}}FilterFunc) {{.Type}} {
	var result {{.Type}}
	for _, item := range collection {
		if eligible(item) {
			result = append(result, item)
		}
	}
	return result
}

func (collection {{.Type}}) First() {{.ItemType}} {
	if len(collection) == 0 {
		return {{.ItemType}}{}
	}
	return collection[0]
}

type {{.ItemType}}LessFunc func(item, other {{.ItemType}}) bool

func (collection {{.Type}}) Sort(less {{.ItemType}}LessFunc) {{.Type}} {
	cCopy := collection
	sort.Slice(cCopy, func(i, j int) bool {
		return less(cCopy[i], cCopy[j])
	})
	return cCopy
}

type {{.ItemType}}ApplyFunc func(item {{.ItemType}})

func (collection {{.Type}}) Apply(applyFunc {{.ItemType}}ApplyFunc) {
	for _, item := range collection {
		applyFunc(item)
	}
}

func (collection {{.Type}}) Println() {
	collection.Apply(func(item {{.ItemType}}) {
		fmt.Println(item)
	})
}

func (collection {{.Type}}) Print() {
	collection.Apply(func(item {{.ItemType}}) {
		fmt.Print(item)
	})
}

func (collection {{.Type}}) String() string {
	var result string
	for _, item := range collection {
		result = result + fmt.Sprintln(item)
	}
	return result
}
`
